// In-memory ELF execution stub
// Extracts the blob stored in the header (generated by the make file),
// decompresses it using zlib DEFLATE, then executes that.

// Blind use of zlib causes the stub to add 700k of wrapping bloat
// on top of the compressed executable.  So instead this
// uses the tinf library (https://github.com/jibsen/tinf),
// optimized with exactly the operation it needs.

#define _GNU_SOURCE
#include <sys/mman.h>

#include <unistd.h>
#include <sys/syscall.h>
#include <stdlib.h>
#include <stdio.h>

#include "tinf.h"
#include "presh_payload.h"
//unsigned char ___out_presh_bin_deflate[] = { '\00' };
//unsigned int ___out_presh_bin_deflate_len = 1;

void die() {
    // perror("extract error");
    write(STDERR_FILENO, "extract error\n", 14);
    _exit(1);
}

int main(int argc, char *argv[], char *envp[]) {
    int ret;

    unsigned int destSize = ___presh_len;
    unsigned char *dest = malloc(destSize);
    if (!dest) {
        die();
    }
    ret = tinf_uncompress(dest, &destSize, ___presh_z, ___presh_z_len);
    if (ret < 0) {
        die();
    }
    if (ret != TINF_OK) {
        die();
    }

    // 1) Create an anonymous in-memory file via memfd_create()
    int fd = syscall(SYS_memfd_create, "payload_memfd", MFD_CLOEXEC);
    if (fd < 0) {
        die();
    }

    // 2) Write the decompressed data to the memfd
    if (write(fd, dest, destSize) != (ssize_t)destSize) {
        die();
    }

    // 3) Rewind the memfd
    if (lseek(fd, 0, SEEK_SET) < 0) {
        die();
    }

    // 4) Execute the in-memory ELF
    //    fexecve(2) is GNU extension; glibc wrapper available.
    if (fexecve(fd, argv, envp) < 0) {
        die();
    }

    // Should never reach here
    return 0;
}
